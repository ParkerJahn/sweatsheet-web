[
  {
    "projectId": "3a106563-0020-4542-9d75-487c66b551f4",
    "testId": "3553d0a3-9c2c-48dd-89fd-f55946942eb1",
    "userId": "c448b4b8-3021-7040-23b4-3ced454d1581",
    "title": "TC001-user registration with role selection",
    "description": "Test the user registration API to ensure new users can register with a valid username, password, email, first name, last name, and role selection (PRO, ATHLETE, SWEAT_TEAM_MEMBER). Verify successful creation and proper validation error handling.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nREGISTER_ENDPOINT = f\"{BASE_URL}/api/register/\"\nTIMEOUT = 30\n\ndef test_user_registration_with_role_selection():\n    headers = {\"Content-Type\": \"application/json\"}\n    roles = [\"PRO\", \"ATHLETE\", \"SWEAT_TEAM_MEMBER\"]\n\n    # Test successful registration for each role\n    for role in roles:\n        unique_suffix = str(uuid.uuid4())[:8]\n        payload = {\n            \"username\": f\"user_{role.lower()}_{unique_suffix}\",\n            \"password\": \"StrongPass!123\",\n            \"password2\": \"StrongPass!123\",\n            \"email\": f\"{role.lower()}_{unique_suffix}@example.com\",\n            \"first_name\": f\"First{role}\",\n            \"last_name\": f\"Last{role}\",\n            \"profile\": {\n                \"role\": role\n            }\n        }\n        try:\n            response = requests.post(REGISTER_ENDPOINT, json=payload, headers=headers, timeout=TIMEOUT)\n        except requests.RequestException as e:\n            assert False, f\"Request failed for role {role}: {e}\"\n\n        assert response.status_code == 201, f\"Expected 201 Created for role {role}, got {response.status_code}\"\n\n    # Test validation error: missing required fields\n    invalid_payloads = [\n        # Missing username\n        {\n            \"password\": \"StrongPass!123\",\n            \"password2\": \"StrongPass!123\",\n            \"email\": \"invalid@example.com\",\n            \"first_name\": \"First\",\n            \"last_name\": \"Last\",\n            \"profile\": {\"role\": \"PRO\"}\n        },\n        # Passwords do not match\n        {\n            \"username\": \"user_invalid_pw\",\n            \"password\": \"StrongPass!123\",\n            \"password2\": \"WrongPass!123\",\n            \"email\": \"invalidpw@example.com\",\n            \"first_name\": \"First\",\n            \"last_name\": \"Last\",\n            \"profile\": {\"role\": \"ATHLETE\"}\n        },\n        # Invalid email format\n        {\n            \"username\": \"user_invalid_email\",\n            \"password\": \"StrongPass!123\",\n            \"password2\": \"StrongPass!123\",\n            \"email\": \"not-an-email\",\n            \"first_name\": \"First\",\n            \"last_name\": \"Last\",\n            \"profile\": {\"role\": \"SWEAT_TEAM_MEMBER\"}\n        },\n        # Invalid role\n        {\n            \"username\": \"user_invalid_role\",\n            \"password\": \"StrongPass!123\",\n            \"password2\": \"StrongPass!123\",\n            \"email\": \"valid@example.com\",\n            \"first_name\": \"First\",\n            \"last_name\": \"Last\",\n            \"profile\": {\"role\": \"INVALID_ROLE\"}\n        }\n    ]\n\n    for idx, invalid_payload in enumerate(invalid_payloads, start=1):\n        try:\n            response = requests.post(REGISTER_ENDPOINT, json=invalid_payload, headers=headers, timeout=TIMEOUT)\n        except requests.RequestException as e:\n            assert False, f\"Request failed for invalid payload #{idx}: {e}\"\n\n        assert response.status_code == 400, f\"Expected 400 Bad Request for invalid payload #{idx}, got {response.status_code}\"\n\ntest_user_registration_with_role_selection()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 27, in test_user_registration_with_role_selection\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 84, in <module>\n  File \"<string>\", line 29, in test_user_registration_with_role_selection\nAssertionError: Request failed for role PRO: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-07T18:21:41.312Z",
    "modified": "2025-08-07T18:26:05.418Z"
  },
  {
    "projectId": "3a106563-0020-4542-9d75-487c66b551f4",
    "testId": "a9a852b4-f2cb-4133-9381-5cd84a07f33f",
    "userId": "c448b4b8-3021-7040-23b4-3ced454d1581",
    "title": "TC002-jwt authentication token issuance and refresh",
    "description": "Test the JWT authentication API to verify that users can obtain access and refresh tokens with valid credentials and can refresh the access token using a valid refresh token. Check for proper error responses on invalid credentials or tokens.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_jwt_authentication_token_issuance_and_refresh():\n    # Create a unique user for testing\n    username = f\"testuser_{uuid.uuid4().hex[:8]}\"\n    password = \"TestPass123!\"\n    email = f\"{username}@example.com\"\n    first_name = \"Test\"\n    last_name = \"User\"\n    role = \"PRO\"\n\n    register_url = f\"{BASE_URL}/api/register/\"\n    token_url = f\"{BASE_URL}/api/token/\"\n    refresh_url = f\"{BASE_URL}/api/token/refresh/\"\n\n    user_id = None\n\n    try:\n        # Register user\n        register_payload = {\n            \"username\": username,\n            \"password\": password,\n            \"password2\": password,\n            \"email\": email,\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"profile\": {\n                \"role\": role\n            }\n        }\n        r = requests.post(register_url, json=register_payload, timeout=TIMEOUT)\n        assert r.status_code == 201, f\"User registration failed: {r.text}\"\n\n        # Obtain JWT tokens with valid credentials\n        token_payload = {\n            \"username\": username,\n            \"password\": password\n        }\n        r = requests.post(token_url, json=token_payload, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Token obtain failed with valid credentials: {r.text}\"\n        tokens = r.json()\n        assert \"access\" in tokens and isinstance(tokens[\"access\"], str) and tokens[\"access\"], \"Access token missing or invalid\"\n        assert \"refresh\" in tokens and isinstance(tokens[\"refresh\"], str) and tokens[\"refresh\"], \"Refresh token missing or invalid\"\n\n        access_token = tokens[\"access\"]\n        refresh_token = tokens[\"refresh\"]\n\n        # Attempt to obtain tokens with invalid credentials\n        invalid_token_payload = {\n            \"username\": username,\n            \"password\": \"WrongPassword!\"\n        }\n        r = requests.post(token_url, json=invalid_token_payload, timeout=TIMEOUT)\n        assert r.status_code == 401, \"Token obtain did not fail with invalid credentials\"\n\n        # Refresh access token with valid refresh token\n        refresh_payload = {\n            \"refresh\": refresh_token\n        }\n        r = requests.post(refresh_url, json=refresh_payload, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Token refresh failed with valid refresh token: {r.text}\"\n        refreshed = r.json()\n        assert \"access\" in refreshed and isinstance(refreshed[\"access\"], str) and refreshed[\"access\"], \"Refreshed access token missing or invalid\"\n\n        # Refresh access token with invalid refresh token\n        invalid_refresh_payload = {\n            \"refresh\": \"invalidtoken123\"\n        }\n        r = requests.post(refresh_url, json=invalid_refresh_payload, timeout=TIMEOUT)\n        assert r.status_code == 401, \"Token refresh did not fail with invalid refresh token\"\n\n    finally:\n        # Cleanup: delete the created user if possible\n        # Since no delete user API is described, skip cleanup or implement if available\n        pass\n\ntest_jwt_authentication_token_issuance_and_refresh()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 81, in <module>\n  File \"<string>\", line 35, in test_jwt_authentication_token_issuance_and_refresh\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-07T18:21:41.319Z",
    "modified": "2025-08-07T18:26:05.434Z"
  },
  {
    "projectId": "3a106563-0020-4542-9d75-487c66b551f4",
    "testId": "6128ff48-8891-4c98-a937-4cf6a8b4bc5e",
    "userId": "c448b4b8-3021-7040-23b4-3ced454d1581",
    "title": "TC003-profile management view and update",
    "description": "Test the profile management API to ensure authenticated users can retrieve their profile information and update fields such as first name, last name, email, and phone number. Verify role-based permissions and validation error handling.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_profile_management_view_and_update():\n    # Test user credentials and registration data\n    register_url = f\"{BASE_URL}/api/register/\"\n    token_url = f\"{BASE_URL}/api/token/\"\n    profile_url = f\"{BASE_URL}/api/profile/\"\n\n    user_data = {\n        \"username\": \"testuser_tc003\",\n        \"password\": \"StrongPass!123\",\n        \"password2\": \"StrongPass!123\",\n        \"email\": \"testuser_tc003@example.com\",\n        \"first_name\": \"Test\",\n        \"last_name\": \"User\",\n        \"profile\": {\n            \"phone_number\": \"1234567890\",\n            \"role\": \"PRO\"\n        }\n    }\n\n    updated_profile_data_valid = {\n        \"first_name\": \"UpdatedFirst\",\n        \"last_name\": \"UpdatedLast\",\n        \"email\": \"updated_email_tc003@example.com\",\n        \"phone_number\": \"0987654321\"\n    }\n\n    updated_profile_data_invalid_email = {\n        \"email\": \"invalid-email-format\"\n    }\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Register user\n    try:\n        r = requests.post(register_url, json=user_data, headers=headers, timeout=TIMEOUT)\n        assert r.status_code == 201, f\"User registration failed: {r.status_code} {r.text}\"\n    except Exception as e:\n        raise AssertionError(f\"User registration request failed: {e}\")\n\n    # Obtain JWT token\n    token_payload = {\n        \"username\": user_data[\"username\"],\n        \"password\": user_data[\"password\"]\n    }\n    try:\n        r = requests.post(token_url, json=token_payload, headers=headers, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Token obtain failed: {r.status_code} {r.text}\"\n        tokens = r.json()\n        access_token = tokens.get(\"access\")\n        assert access_token, \"Access token missing in response\"\n    except Exception as e:\n        raise AssertionError(f\"Token obtain request failed: {e}\")\n\n    auth_headers = {\n        \"Authorization\": f\"Bearer {access_token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Retrieve profile (GET)\n    try:\n        r = requests.get(profile_url, headers=auth_headers, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Profile retrieval failed: {r.status_code} {r.text}\"\n        profile = r.json()\n        # Validate returned fields\n        assert profile.get(\"username\") == user_data[\"username\"]\n        assert profile.get(\"first_name\") == user_data[\"first_name\"]\n        assert profile.get(\"last_name\") == user_data[\"last_name\"]\n        assert profile.get(\"email\") == user_data[\"email\"]\n        profile_obj = profile.get(\"profile\", {})\n        assert profile_obj.get(\"role\") == user_data[\"profile\"][\"role\"]\n        assert profile_obj.get(\"phone_number\") == user_data[\"profile\"][\"phone_number\"]\n    except Exception as e:\n        raise AssertionError(f\"Profile retrieval request failed: {e}\")\n\n    # Update profile with valid data (PATCH)\n    try:\n        r = requests.patch(profile_url, json=updated_profile_data_valid, headers=auth_headers, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Profile update failed: {r.status_code} {r.text}\"\n    except Exception as e:\n        raise AssertionError(f\"Profile update request failed: {e}\")\n\n    # Verify updated profile fields\n    try:\n        r = requests.get(profile_url, headers=auth_headers, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Profile retrieval after update failed: {r.status_code} {r.text}\"\n        profile = r.json()\n        assert profile.get(\"first_name\") == updated_profile_data_valid[\"first_name\"]\n        assert profile.get(\"last_name\") == updated_profile_data_valid[\"last_name\"]\n        assert profile.get(\"email\") == updated_profile_data_valid[\"email\"]\n        profile_obj = profile.get(\"profile\", {})\n        assert profile_obj.get(\"phone_number\") == updated_profile_data_valid[\"phone_number\"]\n    except Exception as e:\n        raise AssertionError(f\"Profile retrieval after update request failed: {e}\")\n\n    # Attempt update with invalid email to test validation error (PATCH)\n    try:\n        r = requests.patch(profile_url, json=updated_profile_data_invalid_email, headers=auth_headers, timeout=TIMEOUT)\n        assert r.status_code == 400, f\"Invalid email update should fail with 400, got {r.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Invalid email update request failed: {e}\")\n\n    # Verify role-based permission: try to update role field (should not be allowed or ignored)\n    # Since role is not in update schema, test that role cannot be changed by patching profile.role\n    # Attempt to patch role via profile object (should be ignored or rejected)\n    invalid_role_update = {\n        \"role\": \"ATHLETE\"\n    }\n    try:\n        r = requests.patch(profile_url, json=invalid_role_update, headers=auth_headers, timeout=TIMEOUT)\n        # The API schema does not allow role update via this endpoint, so expect either 200 with no change or 400\n        if r.status_code == 200:\n            # Confirm role unchanged\n            r2 = requests.get(profile_url, headers=auth_headers, timeout=TIMEOUT)\n            assert r2.status_code == 200, f\"Profile retrieval failed: {r2.status_code} {r2.text}\"\n            profile = r2.json()\n            profile_obj = profile.get(\"profile\", {})\n            assert profile_obj.get(\"role\") == user_data[\"profile\"][\"role\"], \"Role should not be changed by patch\"\n        else:\n            assert r.status_code == 400, f\"Unexpected status code for role update attempt: {r.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Role update attempt request failed: {e}\")\n\n    # Cleanup: delete the created user if API supports it (not specified in PRD)\n    # No delete user endpoint specified, so skipping cleanup\n\ntest_profile_management_view_and_update()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 40, in test_profile_management_view_and_update\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 131, in <module>\n  File \"<string>\", line 43, in test_profile_management_view_and_update\nAssertionError: User registration request failed: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-07T18:21:41.326Z",
    "modified": "2025-08-07T18:25:35.358Z"
  },
  {
    "projectId": "3a106563-0020-4542-9d75-487c66b551f4",
    "testId": "261d1861-f253-41b9-a502-7b4fd6e41260",
    "userId": "c448b4b8-3021-7040-23b4-3ced454d1581",
    "title": "TC004-team management user list retrieval with role filtering",
    "description": "Test the team management API endpoints to verify that users can retrieve the full user list and the filtered list of athletes. Ensure proper role-based access control and correct data retrieval.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_team_management_user_list_retrieval_with_role_filtering():\n    # Register a SweatPro user for authentication\n    pro_register_data = {\n        \"username\": \"testpro_tc004\",\n        \"password\": \"StrongPass!234\",\n        \"password2\": \"StrongPass!234\",\n        \"email\": \"testpro_tc004@example.com\",\n        \"first_name\": \"Test\",\n        \"last_name\": \"Pro\",\n        \"profile\": {\n            \"role\": \"PRO\"\n        }\n    }\n    # Register a SweatAthlete user for testing athlete list retrieval\n    athlete_register_data = {\n        \"username\": \"testathlete_tc004\",\n        \"password\": \"StrongPass!234\",\n        \"password2\": \"StrongPass!234\",\n        \"email\": \"testathlete_tc004@example.com\",\n        \"first_name\": \"Test\",\n        \"last_name\": \"Athlete\",\n        \"profile\": {\n            \"role\": \"ATHLETE\"\n        }\n    }\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    try:\n        # Register SweatPro user\n        r = requests.post(f\"{BASE_URL}/api/register/\", json=pro_register_data, headers=headers, timeout=TIMEOUT)\n        assert r.status_code == 201, f\"Failed to register SweatPro user: {r.text}\"\n\n        # Register SweatAthlete user\n        r = requests.post(f\"{BASE_URL}/api/register/\", json=athlete_register_data, headers=headers, timeout=TIMEOUT)\n        assert r.status_code == 201, f\"Failed to register SweatAthlete user: {r.text}\"\n\n        # Authenticate as SweatPro to get JWT token\n        auth_data = {\n            \"username\": pro_register_data[\"username\"],\n            \"password\": pro_register_data[\"password\"]\n        }\n        r = requests.post(f\"{BASE_URL}/api/token/\", json=auth_data, headers=headers, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Failed to authenticate SweatPro user: {r.text}\"\n        tokens = r.json()\n        access_token = tokens.get(\"access\")\n        assert access_token, \"No access token received\"\n\n        auth_headers = {\n            \"Authorization\": f\"Bearer {access_token}\"\n        }\n\n        # Retrieve full user list (team view)\n        r = requests.get(f\"{BASE_URL}/api/users/\", headers=auth_headers, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Failed to retrieve full user list: {r.text}\"\n        users = r.json()\n        assert isinstance(users, list), \"Full user list response is not a list\"\n        # Check that both registered users are in the list by username\n        usernames = [user.get(\"username\") for user in users]\n        assert pro_register_data[\"username\"] in usernames, \"SweatPro user not found in full user list\"\n        assert athlete_register_data[\"username\"] in usernames, \"SweatAthlete user not found in full user list\"\n\n        # Retrieve filtered list of athletes\n        r = requests.get(f\"{BASE_URL}/api/users/athletes/\", headers=auth_headers, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Failed to retrieve athletes list: {r.text}\"\n        athletes = r.json()\n        assert isinstance(athletes, list), \"Athletes list response is not a list\"\n        # All returned users should have role ATHLETE\n        for athlete in athletes:\n            profile = athlete.get(\"profile\", {})\n            role = profile.get(\"role\")\n            assert role == \"ATHLETE\", f\"Non-athlete user found in athletes list: {athlete}\"\n\n        # Authenticate as SweatAthlete to test role-based access control for athletes\n        auth_data_athlete = {\n            \"username\": athlete_register_data[\"username\"],\n            \"password\": athlete_register_data[\"password\"]\n        }\n        r = requests.post(f\"{BASE_URL}/api/token/\", json=auth_data_athlete, headers=headers, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Failed to authenticate SweatAthlete user: {r.text}\"\n        tokens_athlete = r.json()\n        access_token_athlete = tokens_athlete.get(\"access\")\n        assert access_token_athlete, \"No access token received for athlete\"\n\n        auth_headers_athlete = {\n            \"Authorization\": f\"Bearer {access_token_athlete}\"\n        }\n\n        # SweatAthlete tries to retrieve full user list - expect 403 or 200 depending on permissions\n        r = requests.get(f\"{BASE_URL}/api/users/\", headers=auth_headers_athlete, timeout=TIMEOUT)\n        # According to role-based access control, athletes may or may not have access.\n        # We accept 200 or 403 but if 200, verify data structure\n        assert r.status_code in (200, 403), f\"Unexpected status code for athlete retrieving full user list: {r.status_code}\"\n        if r.status_code == 200:\n            users_athlete = r.json()\n            assert isinstance(users_athlete, list), \"Athlete full user list response is not a list\"\n\n        # SweatAthlete tries to retrieve athletes list - expect 403 (insufficient permissions)\n        r = requests.get(f\"{BASE_URL}/api/users/athletes/\", headers=auth_headers_athlete, timeout=TIMEOUT)\n        assert r.status_code == 403, f\"Expected 403 for athlete retrieving athletes list, got {r.status_code}\"\n\n    finally:\n        # Cleanup: delete the created users if API supports user deletion (not specified in PRD)\n        # Since no user deletion endpoint is specified, skipping cleanup.\n        pass\n\ntest_team_management_user_list_retrieval_with_role_filtering()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 112, in <module>\n  File \"<string>\", line 36, in test_team_management_user_list_retrieval_with_role_filtering\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-07T18:21:41.333Z",
    "modified": "2025-08-07T18:28:05.605Z"
  },
  {
    "projectId": "3a106563-0020-4542-9d75-487c66b551f4",
    "testId": "f1a2276d-fda5-46bc-acce-1a7c88720a0e",
    "userId": "c448b4b8-3021-7040-23b4-3ced454d1581",
    "title": "TC005-sweatsheet management create list and assign",
    "description": "Test the SweatSheet management API to verify that SweatPros can create new SweatSheets, list SweatSheets based on user role, retrieve details of a specific SweatSheet, and assign SweatSheets to athletes. Validate permission checks and data integrity.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_sweatsheet_management_create_list_and_assign():\n    # Helper functions\n    def register_user(username, password, email, first_name, last_name, role):\n        url = f\"{BASE_URL}/api/register/\"\n        payload = {\n            \"username\": username,\n            \"password\": password,\n            \"password2\": password,\n            \"email\": email,\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"profile\": {\n                \"role\": role\n            }\n        }\n        resp = requests.post(url, json=payload, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp\n\n    def get_token(username, password):\n        url = f\"{BASE_URL}/api/token/\"\n        payload = {\"username\": username, \"password\": password}\n        resp = requests.post(url, json=payload, timeout=TIMEOUT)\n        resp.raise_for_status()\n        tokens = resp.json()\n        assert \"access\" in tokens and \"refresh\" in tokens\n        return tokens[\"access\"]\n\n    def create_sweatsheet(token, title, description=None, is_template=False):\n        url = f\"{BASE_URL}/api/sweatsheets/\"\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        payload = {\"title\": title, \"is_template\": is_template}\n        if description is not None:\n            payload[\"description\"] = description\n        resp = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n        return resp\n\n    def list_sweatsheets(token):\n        url = f\"{BASE_URL}/api/sweatsheets/\"\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        resp = requests.get(url, headers=headers, timeout=TIMEOUT)\n        return resp\n\n    def get_sweatsheet_details(token, sweatsheet_id):\n        url = f\"{BASE_URL}/api/sweatsheets/{sweatsheet_id}/\"\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        resp = requests.get(url, headers=headers, timeout=TIMEOUT)\n        return resp\n\n    def assign_sweatsheet(token, sweatsheet_id, athlete_ids):\n        url = f\"{BASE_URL}/api/sweatsheets/{sweatsheet_id}/assign/\"\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        payload = {\"athletes\": athlete_ids}\n        resp = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n        return resp\n\n    def get_athletes(token):\n        url = f\"{BASE_URL}/api/users/athletes/\"\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        resp = requests.get(url, headers=headers, timeout=TIMEOUT)\n        return resp\n\n    def delete_sweatsheet(token, sweatsheet_id):\n        # No explicit delete endpoint in PRD for sweatsheets, so skip deletion\n        # If needed, implement here\n        pass\n\n    # Register a SweatPro user\n    pro_username = f\"pro_{uuid.uuid4().hex[:8]}\"\n    pro_password = \"StrongPass!123\"\n    pro_email = f\"{pro_username}@example.com\"\n    pro_first_name = \"ProFirst\"\n    pro_last_name = \"ProLast\"\n    pro_role = \"PRO\"\n\n    resp = register_user(pro_username, pro_password, pro_email, pro_first_name, pro_last_name, pro_role)\n    assert resp.status_code == 201\n\n    pro_token = get_token(pro_username, pro_password)\n\n    # Register an athlete user to assign sweatSheet to\n    athlete_username = f\"athlete_{uuid.uuid4().hex[:8]}\"\n    athlete_password = \"StrongPass!123\"\n    athlete_email = f\"{athlete_username}@example.com\"\n    athlete_first_name = \"AthleteFirst\"\n    athlete_last_name = \"AthleteLast\"\n    athlete_role = \"ATHLETE\"\n\n    resp = register_user(athlete_username, athlete_password, athlete_email, athlete_first_name, athlete_last_name, athlete_role)\n    assert resp.status_code == 201\n\n    athlete_token = get_token(athlete_username, athlete_password)\n\n    # Get athlete user id from /api/users/athletes/ endpoint (to confirm athlete id)\n    resp = get_athletes(pro_token)\n    assert resp.status_code == 200\n    athletes_list = resp.json()\n    athlete_ids = [a[\"id\"] for a in athletes_list if a[\"username\"] == athlete_username]\n    assert len(athlete_ids) == 1\n    athlete_id = athlete_ids[0]\n\n    # Create a new SweatSheet as SweatPro\n    sweatsheet_title = f\"Test SweatSheet {uuid.uuid4().hex[:6]}\"\n    sweatsheet_description = \"Test description for SweatSheet\"\n    resp = create_sweatsheet(pro_token, sweatsheet_title, sweatsheet_description, is_template=False)\n    assert resp.status_code == 201\n    sweatsheet = resp.json()\n    assert \"id\" in sweatsheet\n    sweatsheet_id = sweatsheet[\"id\"]\n\n    try:\n        # List SweatSheets as SweatPro and verify the created one is present\n        resp = list_sweatsheets(pro_token)\n        assert resp.status_code == 200\n        sheets = resp.json()\n        assert any(s[\"id\"] == sweatsheet_id and s[\"title\"] == sweatsheet_title for s in sheets)\n\n        # Retrieve details of the specific SweatSheet\n        resp = get_sweatsheet_details(pro_token, sweatsheet_id)\n        assert resp.status_code == 200\n        details = resp.json()\n        assert details[\"id\"] == sweatsheet_id\n        assert details[\"title\"] == sweatsheet_title\n        assert details.get(\"description\") == sweatsheet_description\n\n        # Assign the SweatSheet to the athlete\n        resp = assign_sweatsheet(pro_token, sweatsheet_id, [athlete_id])\n        assert resp.status_code == 200\n\n        # Verify athlete cannot create a SweatSheet (permission check)\n        resp = create_sweatsheet(athlete_token, \"Athlete Sheet\")\n        assert resp.status_code == 403\n\n        # Verify athlete can list their assigned SweatSheets (should include the assigned one)\n        resp = list_sweatsheets(athlete_token)\n        assert resp.status_code == 200\n        athlete_sheets = resp.json()\n        assert any(s[\"id\"] == sweatsheet_id for s in athlete_sheets)\n\n        # Verify athlete can get details of assigned SweatSheet\n        resp = get_sweatsheet_details(athlete_token, sweatsheet_id)\n        assert resp.status_code == 200\n        athlete_sheet_details = resp.json()\n        assert athlete_sheet_details[\"id\"] == sweatsheet_id\n\n        # Verify permission denied when non-Pro tries to assign SweatSheet\n        resp = assign_sweatsheet(athlete_token, sweatsheet_id, [athlete_id])\n        assert resp.status_code == 403\n\n    finally:\n        # Cleanup: No delete endpoint for sweatsheets specified, so skipping deletion\n        pass\n\ntest_sweatsheet_management_create_list_and_assign()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 160, in <module>\n  File \"<string>\", line 82, in test_sweatsheet_management_create_list_and_assign\n  File \"<string>\", line 22, in register_user\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-07T18:21:41.339Z",
    "modified": "2025-08-07T18:26:05.432Z"
  },
  {
    "projectId": "3a106563-0020-4542-9d75-487c66b551f4",
    "testId": "04f19d2a-6207-4032-8a4f-9a37a936c373",
    "userId": "c448b4b8-3021-7040-23b4-3ced454d1581",
    "title": "TC006-workout exercise library category and exercise retrieval",
    "description": "Test the workout exercise library API to ensure users can retrieve all workout categories and filter workout exercises by category. Verify correct data structure and security enforcement.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# Credentials for an existing user to authenticate and test the API\n# These should be replaced with valid test user credentials in the environment\nTEST_USERNAME = \"testuser\"\nTEST_PASSWORD = \"testpassword\"\n\n\ndef test_workout_exercise_library_category_and_exercise_retrieval():\n    # Authenticate to get JWT token\n    token_url = f\"{BASE_URL}/api/token/\"\n    auth_payload = {\"username\": TEST_USERNAME, \"password\": TEST_PASSWORD}\n    try:\n        auth_resp = requests.post(token_url, json=auth_payload, timeout=TIMEOUT)\n        assert auth_resp.status_code == 200, f\"Authentication failed: {auth_resp.text}\"\n        tokens = auth_resp.json()\n        access_token = tokens.get(\"access\")\n        assert access_token, \"Access token not found in response\"\n    except requests.RequestException as e:\n        assert False, f\"Authentication request failed: {e}\"\n\n    headers = {\"Authorization\": f\"Bearer {access_token}\"}\n\n    # 1. Retrieve all workout categories\n    categories_url = f\"{BASE_URL}/api/workout-categories/\"\n    try:\n        categories_resp = requests.get(categories_url, headers=headers, timeout=TIMEOUT)\n        assert categories_resp.status_code == 200, f\"Failed to get workout categories: {categories_resp.text}\"\n        categories = categories_resp.json()\n        assert isinstance(categories, list), \"Categories response is not a list\"\n        for category in categories:\n            assert isinstance(category, dict), \"Category item is not a dict\"\n            assert \"id\" in category and isinstance(category[\"id\"], int), \"Category missing valid 'id'\"\n            assert \"name\" in category and isinstance(category[\"name\"], str), \"Category missing valid 'name'\"\n            assert \"description\" in category and isinstance(category[\"description\"], str), \"Category missing valid 'description'\"\n    except requests.RequestException as e:\n        assert False, f\"Workout categories request failed: {e}\"\n\n    # 2. For each category, retrieve workout exercises filtered by category_id\n    exercises_url = f\"{BASE_URL}/api/workout-exercises/\"\n    for category in categories:\n        params = {\"category_id\": category[\"id\"]}\n        try:\n            exercises_resp = requests.get(exercises_url, headers=headers, params=params, timeout=TIMEOUT)\n            assert exercises_resp.status_code == 200, f\"Failed to get exercises for category {category['id']}: {exercises_resp.text}\"\n            exercises = exercises_resp.json()\n            assert isinstance(exercises, list), \"Exercises response is not a list\"\n            for exercise in exercises:\n                assert isinstance(exercise, dict), \"Exercise item is not a dict\"\n                assert \"id\" in exercise and isinstance(exercise[\"id\"], int), \"Exercise missing valid 'id'\"\n                assert \"name\" in exercise and isinstance(exercise[\"name\"], str), \"Exercise missing valid 'name'\"\n                assert \"description\" in exercise and isinstance(exercise[\"description\"], str), \"Exercise missing valid 'description'\"\n                assert \"category\" in exercise and exercise[\"category\"] == category[\"id\"], \"Exercise category mismatch\"\n        except requests.RequestException as e:\n            assert False, f\"Workout exercises request failed for category {category['id']}: {e}\"\n\n    # 3. Test security enforcement: try to access categories without token\n    try:\n        no_auth_resp = requests.get(categories_url, timeout=TIMEOUT)\n        assert no_auth_resp.status_code == 401, \"Unauthorized access to workout categories did not return 401\"\n    except requests.RequestException as e:\n        assert False, f\"Unauthorized workout categories request failed: {e}\"\n\n    # 4. Test security enforcement: try to access exercises without token\n    try:\n        no_auth_resp = requests.get(exercises_url, timeout=TIMEOUT)\n        assert no_auth_resp.status_code == 401, \"Unauthorized access to workout exercises did not return 401\"\n    except requests.RequestException as e:\n        assert False, f\"Unauthorized workout exercises request failed: {e}\"\n\n\ntest_workout_exercise_library_category_and_exercise_retrieval()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 17, in test_workout_exercise_library_category_and_exercise_retrieval\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 75, in <module>\n  File \"<string>\", line 23, in test_workout_exercise_library_category_and_exercise_retrieval\nAssertionError: Authentication request failed: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-07T18:21:41.345Z",
    "modified": "2025-08-07T18:26:05.431Z"
  },
  {
    "projectId": "3a106563-0020-4542-9d75-487c66b551f4",
    "testId": "63c79002-b1d1-4f19-b681-a01d29ea5b86",
    "userId": "c448b4b8-3021-7040-23b4-3ced454d1581",
    "title": "TC007-calendar management get and update events",
    "description": "Test the calendar management API to verify that users can retrieve their calendar events and update them. Ensure that events include correct details such as id, time, title, type, and duration, and that updates are persisted.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# Credentials for a test user (should exist in the system or be created beforehand)\nTEST_USERNAME = \"testuser_tc007\"\nTEST_PASSWORD = \"TestPass123!\"\nTEST_EMAIL = \"testuser_tc007@example.com\"\nTEST_FIRST_NAME = \"Test\"\nTEST_LAST_NAME = \"User\"\nTEST_ROLE = \"ATHLETE\"  # Assuming calendar events are per user, ATHLETE role is suitable\n\ndef register_user():\n    url = f\"{BASE_URL}/api/register/\"\n    payload = {\n        \"username\": TEST_USERNAME,\n        \"password\": TEST_PASSWORD,\n        \"password2\": TEST_PASSWORD,\n        \"email\": TEST_EMAIL,\n        \"first_name\": TEST_FIRST_NAME,\n        \"last_name\": TEST_LAST_NAME,\n        \"profile\": {\n            \"role\": TEST_ROLE\n        }\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    if resp.status_code == 201:\n        return True\n    elif resp.status_code == 400 and \"username\" in resp.text:\n        # User likely already exists\n        return True\n    else:\n        resp.raise_for_status()\n\ndef get_jwt_token():\n    url = f\"{BASE_URL}/api/token/\"\n    payload = {\n        \"username\": TEST_USERNAME,\n        \"password\": TEST_PASSWORD\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    tokens = resp.json()\n    assert \"access\" in tokens and \"refresh\" in tokens\n    return tokens[\"access\"]\n\ndef test_calendar_management_get_and_update_events():\n    # Ensure test user exists and get token\n    register_user()\n    token = get_jwt_token()\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    # Step 1: GET current calendar events\n    get_url = f\"{BASE_URL}/api/calendar/\"\n    resp = requests.get(get_url, headers=headers, timeout=TIMEOUT)\n    assert resp.status_code == 200\n    calendar_data = resp.json()\n    assert \"events\" in calendar_data\n    # events is an object with keys (e.g. dates) mapping to arrays of event objects\n    events_obj = calendar_data[\"events\"]\n    assert isinstance(events_obj, dict)\n\n    # Collect all events in a list for easier manipulation\n    all_events = []\n    for key, events_list in events_obj.items():\n        assert isinstance(events_list, list)\n        for event in events_list:\n            # Validate event fields\n            assert isinstance(event, dict)\n            assert \"id\" in event and isinstance(event[\"id\"], int)\n            assert \"time\" in event and isinstance(event[\"time\"], str)\n            assert \"title\" in event and isinstance(event[\"title\"], str)\n            assert \"type\" in event and event[\"type\"] in [\"meeting\", \"availability\"]\n            assert \"duration\" in event and isinstance(event[\"duration\"], int)\n            all_events.append(event)\n\n    # Prepare updated events payload\n    # If no events exist, create a dummy event to update\n    if not all_events:\n        # Create a new availability event for today with a unique title\n        now_iso = time.strftime(\"%Y-%m-%dT%H:%M:%S\")  # approximate current time ISO format without timezone\n        new_event = {\n            \"id\": 1,\n            \"time\": now_iso,\n            \"title\": f\"Test Event {uuid.uuid4()}\",\n            \"type\": \"availability\",\n            \"duration\": 60\n        }\n        updated_events = {time.strftime(\"%Y-%m-%d\"): [new_event]}\n    else:\n        # Modify the title of the first event to a unique value\n        updated_events = {}\n        for key, events_list in events_obj.items():\n            updated_events[key] = []\n            for event in events_list:\n                if event == all_events[0]:\n                    event[\"title\"] = f\"Updated Title {uuid.uuid4()}\"\n                updated_events[key].append(event)\n\n    # Step 2: PUT update calendar events\n    put_url = f\"{BASE_URL}/api/calendar/\"\n    put_payload = {\"events\": updated_events}\n    put_resp = requests.put(put_url, headers=headers, json=put_payload, timeout=TIMEOUT)\n    assert put_resp.status_code == 200\n\n    # Step 3: GET calendar events again to verify update persisted\n    verify_resp = requests.get(get_url, headers=headers, timeout=TIMEOUT)\n    assert verify_resp.status_code == 200\n    verify_data = verify_resp.json()\n    assert \"events\" in verify_data\n    verify_events_obj = verify_data[\"events\"]\n    assert isinstance(verify_events_obj, dict)\n\n    # Check that the updated event title is present\n    found_updated = False\n    for key, events_list in verify_events_obj.items():\n        for event in events_list:\n            if event[\"id\"] == (all_events[0][\"id\"] if all_events else 1):\n                expected_title = updated_events[key][0][\"title\"] if all_events else updated_events[key][0][\"title\"]\n                assert event[\"title\"] == expected_title\n                found_updated = True\n                # Validate other fields remain consistent\n                assert \"time\" in event and isinstance(event[\"time\"], str)\n                assert \"type\" in event and event[\"type\"] in [\"meeting\", \"availability\"]\n                assert \"duration\" in event and isinstance(event[\"duration\"], int)\n    assert found_updated, \"Updated event not found in calendar after update.\"\n\ntest_calendar_management_get_and_update_events()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 131, in <module>\n  File \"<string>\", line 52, in test_calendar_management_get_and_update_events\n  File \"<string>\", line 29, in register_user\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-07T18:21:41.358Z",
    "modified": "2025-08-07T18:29:25.953Z"
  },
  {
    "projectId": "3a106563-0020-4542-9d75-487c66b551f4",
    "testId": "e44a3cfd-96ad-4643-b72a-4003789e1acd",
    "userId": "c448b4b8-3021-7040-23b4-3ced454d1581",
    "title": "TC008-notes management create retrieve and delete",
    "description": "Test the notes management API to ensure users can create new notes, retrieve their notes list, and delete notes by id. Verify proper authentication, authorization, and error handling for non-existent notes.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# Credentials for an existing test user with notes access (should be replaced with valid test user credentials)\nTEST_USERNAME = \"testuser\"\nTEST_PASSWORD = \"testpassword\"\n\ndef get_jwt_token(username, password):\n    url = f\"{BASE_URL}/api/token/\"\n    payload = {\"username\": username, \"password\": password}\n    try:\n        resp = requests.post(url, json=payload, timeout=TIMEOUT)\n        resp.raise_for_status()\n        tokens = resp.json()\n        return tokens.get(\"access\")\n    except requests.RequestException as e:\n        raise RuntimeError(f\"Failed to obtain JWT token: {e}\")\n\ndef test_notes_management_create_retrieve_delete():\n    access_token = get_jwt_token(TEST_USERNAME, TEST_PASSWORD)\n    headers = {\"Authorization\": f\"Bearer {access_token}\"}\n\n    note_id = None\n    try:\n        # 1. Create a new note\n        create_url = f\"{BASE_URL}/api/notes/\"\n        unique_title = f\"Test Note {uuid.uuid4()}\"\n        create_payload = {\n            \"title\": unique_title,\n            \"content\": \"This is a test note content.\"\n        }\n        create_resp = requests.post(create_url, json=create_payload, headers=headers, timeout=TIMEOUT)\n        assert create_resp.status_code == 201, f\"Note creation failed: {create_resp.text}\"\n        created_note = create_resp.json()\n        note_id = created_note.get(\"id\")\n        assert note_id is not None, \"Created note ID is missing\"\n\n        # 2. Retrieve notes list and verify the created note is present\n        list_url = f\"{BASE_URL}/api/notes/\"\n        list_resp = requests.get(list_url, headers=headers, timeout=TIMEOUT)\n        assert list_resp.status_code == 200, f\"Failed to retrieve notes list: {list_resp.text}\"\n        notes_list = list_resp.json()\n        assert any(note.get(\"id\") == note_id and note.get(\"title\") == unique_title for note in notes_list), \\\n            \"Created note not found in notes list\"\n\n        # 3. Delete the created note by id\n        delete_url = f\"{BASE_URL}/api/notes/delete/{note_id}/\"\n        delete_resp = requests.delete(delete_url, headers=headers, timeout=TIMEOUT)\n        assert delete_resp.status_code == 204, f\"Failed to delete note: {delete_resp.text}\"\n\n        # 4. Verify note is deleted by attempting to delete again (should return 404)\n        delete_again_resp = requests.delete(delete_url, headers=headers, timeout=TIMEOUT)\n        assert delete_again_resp.status_code == 404, \"Deleting non-existent note did not return 404\"\n\n        # 5. Verify note is no longer in the notes list\n        list_resp_after_delete = requests.get(list_url, headers=headers, timeout=TIMEOUT)\n        assert list_resp_after_delete.status_code == 200, f\"Failed to retrieve notes list after delete: {list_resp_after_delete.text}\"\n        notes_list_after_delete = list_resp_after_delete.json()\n        assert all(note.get(\"id\") != note_id for note in notes_list_after_delete), \"Deleted note still present in notes list\"\n\n    except AssertionError:\n        raise\n    except Exception as e:\n        raise RuntimeError(f\"Error during notes management test: {e}\")\n\ntest_notes_management_create_retrieve_delete()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 15, in get_jwt_token\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 69, in <module>\n  File \"<string>\", line 23, in test_notes_management_create_retrieve_delete\n  File \"<string>\", line 20, in get_jwt_token\nRuntimeError: Failed to obtain JWT token: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-07T18:21:41.364Z",
    "modified": "2025-08-07T18:29:28.210Z"
  },
  {
    "projectId": "3a106563-0020-4542-9d75-487c66b551f4",
    "testId": "0e74f79b-d193-47b3-8d98-c1211e35992e",
    "userId": "c448b4b8-3021-7040-23b4-3ced454d1581",
    "title": "TC009-exercise progress tracking mark phase and exercise complete",
    "description": "Test the exercise progress tracking API to verify that users can mark phases and exercises as complete. Check for correct status updates and proper handling of invalid or non-existent phase or exercise ids.",
    "code": "import requests\nimport random\nimport string\nimport time\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# Helper functions for user registration and login\ndef random_string(length=8):\n    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n\ndef register_user(username, password, email, first_name, last_name, role):\n    url = f\"{BASE_URL}/api/register/\"\n    payload = {\n        \"username\": username,\n        \"password\": password,\n        \"password2\": password,\n        \"email\": email,\n        \"first_name\": first_name,\n        \"last_name\": last_name,\n        \"profile\": {\n            \"role\": role\n        }\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp\n\ndef get_jwt_token(username, password):\n    url = f\"{BASE_URL}/api/token/\"\n    payload = {\"username\": username, \"password\": password}\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    tokens = resp.json()\n    return tokens[\"access\"], tokens.get(\"refresh\")\n\ndef create_sweatsheet(access_token, title=\"Test SweatSheet\"):\n    url = f\"{BASE_URL}/api/sweatsheets/\"\n    headers = {\"Authorization\": f\"Bearer {access_token}\"}\n    payload = {\"title\": title}\n    resp = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef get_sweatsheet_details(access_token, sweatsheet_id):\n    url = f\"{BASE_URL}/api/sweatsheets/{sweatsheet_id}/\"\n    headers = {\"Authorization\": f\"Bearer {access_token}\"}\n    resp = requests.get(url, headers=headers, timeout=TIMEOUT)\n    if resp.status_code == 404:\n        return None\n    resp.raise_for_status()\n    return resp.json()\n\ndef delete_sweatsheet(access_token, sweatsheet_id):\n    # No delete endpoint documented for sweatsheets, so skip deletion\n    pass\n\ndef find_first_phase_and_exercise(sweatsheet):\n    # The PRD shows phases as array, but no detailed schema for phases or exercises.\n    # We assume phases have id and exercises array with id.\n    phases = sweatsheet.get(\"phases\", [])\n    for phase in phases:\n        phase_id = phase.get(\"id\")\n        exercises = phase.get(\"exercises\", [])\n        for exercise in exercises:\n            exercise_id = exercise.get(\"id\")\n            if phase_id and exercise_id:\n                return phase_id, exercise_id\n    return None, None\n\ndef mark_phase_complete(access_token, phase_id):\n    url = f\"{BASE_URL}/api/phases/{phase_id}/complete/\"\n    headers = {\"Authorization\": f\"Bearer {access_token}\"}\n    resp = requests.post(url, headers=headers, timeout=TIMEOUT)\n    return resp\n\ndef mark_exercise_complete(access_token, exercise_id):\n    url = f\"{BASE_URL}/api/exercises/{exercise_id}/complete/\"\n    headers = {\"Authorization\": f\"Bearer {access_token}\"}\n    resp = requests.post(url, headers=headers, timeout=TIMEOUT)\n    return resp\n\ndef test_exercise_progress_tracking_mark_phase_and_exercise_complete():\n    # Register a new athlete user\n    username = f\"athlete_{random_string(6)}\"\n    password = \"TestPass123!\"\n    email = f\"{username}@example.com\"\n    first_name = \"Test\"\n    last_name = \"Athlete\"\n    role = \"ATHLETE\"\n\n    register_user(username, password, email, first_name, last_name, role)\n\n    access_token, _ = get_jwt_token(username, password)\n    headers = {\"Authorization\": f\"Bearer {access_token}\"}\n\n    # Create a SweatSheet as a SweatPro to have phases and exercises to mark complete\n    # Register and login a SweatPro user\n    pro_username = f\"pro_{random_string(6)}\"\n    pro_password = \"ProPass123!\"\n    pro_email = f\"{pro_username}@example.com\"\n    pro_first_name = \"Test\"\n    pro_last_name = \"Pro\"\n    pro_role = \"PRO\"\n\n    register_user(pro_username, pro_password, pro_email, pro_first_name, pro_last_name, pro_role)\n    pro_access_token, _ = get_jwt_token(pro_username, pro_password)\n\n    # Create a SweatSheet with phases and exercises\n    # Since the PRD does not specify how to add phases/exercises in creation,\n    # we create a basic SweatSheet and then try to get phases/exercises from it.\n    sweatsheet = create_sweatsheet(pro_access_token, title=\"Progress Tracking Test Sheet\")\n\n    sweatsheet_id = sweatsheet.get(\"id\")\n    assert sweatsheet_id is not None, \"Failed to create SweatSheet\"\n\n    # For testing, we need phases and exercises.\n    # If none exist, we cannot proceed with marking complete.\n    # So we try to get details and check phases.\n    sweatsheet_details = get_sweatsheet_details(pro_access_token, sweatsheet_id)\n    assert sweatsheet_details is not None, \"SweatSheet details not found\"\n\n    # If no phases or exercises, we cannot test marking complete.\n    # So we skip test if none found.\n    phase_id, exercise_id = find_first_phase_and_exercise(sweatsheet_details)\n\n    if phase_id is None or exercise_id is None:\n        # Cannot test marking complete without phase and exercise ids\n        # So we skip the marking complete tests but still test error handling with invalid ids\n        phase_id = 9999999  # Non-existent phase id\n        exercise_id = 9999999  # Non-existent exercise id\n    else:\n        # Mark phase as complete - success case\n        resp_phase = mark_phase_complete(access_token, phase_id)\n        assert resp_phase.status_code == 200, f\"Failed to mark phase complete: {resp_phase.text}\"\n\n        # Mark exercise as complete - success case\n        resp_exercise = mark_exercise_complete(access_token, exercise_id)\n        assert resp_exercise.status_code == 200, f\"Failed to mark exercise complete: {resp_exercise.text}\"\n\n    # Test marking non-existent phase as complete - expect 404\n    invalid_phase_id = 9999999\n    resp_invalid_phase = mark_phase_complete(access_token, invalid_phase_id)\n    assert resp_invalid_phase.status_code == 404, \"Expected 404 for non-existent phase id\"\n\n    # Test marking non-existent exercise as complete - expect 404\n    invalid_exercise_id = 9999999\n    resp_invalid_exercise = mark_exercise_complete(access_token, invalid_exercise_id)\n    assert resp_invalid_exercise.status_code == 404, \"Expected 404 for non-existent exercise id\"\n\n    # Test marking phase complete without auth - expect 401\n    url_phase = f\"{BASE_URL}/api/phases/{phase_id}/complete/\"\n    resp_no_auth_phase = requests.post(url_phase, timeout=TIMEOUT)\n    assert resp_no_auth_phase.status_code == 401, \"Expected 401 Unauthorized for phase complete without auth\"\n\n    # Test marking exercise complete without auth - expect 401\n    url_exercise = f\"{BASE_URL}/api/exercises/{exercise_id}/complete/\"\n    resp_no_auth_exercise = requests.post(url_exercise, timeout=TIMEOUT)\n    assert resp_no_auth_exercise.status_code == 401, \"Expected 401 Unauthorized for exercise complete without auth\"\n\ntest_exercise_progress_tracking_mark_phase_and_exercise_complete()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 162, in <module>\n  File \"<string>\", line 93, in test_exercise_progress_tracking_mark_phase_and_exercise_complete\n  File \"<string>\", line 26, in register_user\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-08-07T18:21:41.371Z",
    "modified": "2025-08-07T18:28:08.371Z"
  }
]
